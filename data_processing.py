import json
import re
import pandas as pd
import time
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity 
from FlagEmbedding import FlagModel
from scipy.spatial.distance import cdist 
def origin_data_processing(path):
    try:
        with open(path+'\\permission.txt', 'r',encoding='utf-8') as file:
            permission = file.read()
    except FileNotFoundError:
        permission = ' '
    try:
        with open(path+'\\api.txt', 'r',encoding='utf-8') as file:
            api = file.read()
    except FileNotFoundError:
        api = ' '
    try:
        with open(path+'\\url.txt', 'r',encoding='utf-8') as file:
            url = file.read()
    except FileNotFoundError:
        url=' '
    return permission,api,url


def feature_extraction(path):
    try:
        with open(path+'/permission.txt', 'r',encoding='utf-8') as file:
            permission = [perm.strip() for perm in file.read().strip().split()]

    except FileNotFoundError:
        permission = []
    try:
        with open(path+'/api.txt', 'r',encoding='utf-8') as file:
            api = file.read().strip()
            api_pattern = r'(?P<class_name>\w+(\$\w+)*)\s+(?P<method_name>\w+)\s*\((?P<param_list>[^)]*)\)'
            matches = re.finditer(api_pattern, api)
            api_calls = []
            for match in matches:
                if(len(match.group('method_name'))>4):
                    api_calls.append(match.group(0))
            
    except FileNotFoundError:
        api_calls = []
    try:
        with open(path+'/url.txt', 'r',encoding='utf-8') as file:
            url = file.read()
    except FileNotFoundError:
        url=' '
    permission_api = []
    try:  
        with open('./permission_api_mapping/permission_api_mapping.json', 'r', encoding='utf-8') as file:  
            mapping_table = json.load(file)  
            
            for api_call in api_calls:
                match = re.match(api_pattern, api_call)
                if match:
                    method_name = match.group('method_name')
                    for per in permission:
                        if per in mapping_table:
                            if per.replace("android.permission.","").lower() not in permission_api:
                                permission_api.append(per.replace("android.permission.","").lower())
                            for json_api in mapping_table[per]:
                                if  method_name.lower() in json_api.lower()  and api_call not in permission_api :
                                        permission_api.append(api_call)
                                
    except FileNotFoundError:  
        mapping_table = {}
        print('man,what can I say? Mapping table out!')
    print(len(permission_api))
    str_permission_api = ' '.join(permission_api)
    return str_permission_api,url

def feature_generate(csv_name):
    df = pd.read_csv(csv_name)
    with open('./permission_api_describe/api_describe.json', 'r') as f:  
        data = json.load(f)  
        api_dict = {entry['api_name'].lower(): entry['describe'] for entry in data}  
     
    def replace_features(feature_str):
        feature_names = feature_str.split()
        replaced_features = []
        for feature_name in feature_names:
            lower_feature_name = feature_name.lower()
            if lower_feature_name in api_dict:
                replaced_features.append(api_dict[lower_feature_name])
            else:
                replaced_features.append(lower_feature_name)
            
        return ' '.join(replaced_features)
        
    df['features'] = df['features'].apply(replace_features)
    df.to_csv('feature_generate_realworld.csv',index=False)

 
    

def high_similar_malware_processing_BGE():
    X = np.load('./feature_vector and labels/cic2020_feature_feature_generate.npy')  
    y = np.load('./feature_vector and labels/cic2020_label_feature_generate.npy')
    benign_indices = np.where(y == 0)[0]  
    malicious_indices = np.where(y == 1)[0] 
    
    similarities = X[benign_indices] @ X[malicious_indices].T
    print(similarities)
    threshold = 0.85
    
    max_similarities_per_malware = similarities.max(axis=0)  
    similarity_malicious_indices = np.where(max_similarities_per_malware > threshold)[0]  
    similarity_benign_indices = similarities.argmax(axis=0)[similarity_malicious_indices]  
    similarity_malicious_indices = malicious_indices[similarity_malicious_indices]  
    
   # print(similarity_benign_indices)
   # print(similarity_malicious_indices)

    print(len(similarity_malicious_indices))
    print(len(similarity_benign_indices))

    """
    df = pd.read_csv('./dataset/feature_generate_realworld.csv')
    for benign_idx, malicious_idx in zip(similarity_benign_indices, similarity_malicious_indices):  
        print(benign_idx)
        print(malicious_idx)
        benign_features = df.iloc[benign_idx, df.columns.get_loc('features')]
        malicious_features = df.iloc[malicious_idx, df.columns.get_loc('features')] 
       # print(benign_features)
       # print(malicious_features)
        benign_features = benign_features.split()
        malicious_features = malicious_features.split()
        new_m_features = []
        for m_feature in malicious_features:
            if m_feature not in benign_features:
                new_m_features.append(m_feature)
        new_m_features = " ".join(new_m_features) + " This is a include malicious function"
        
        df.at[malicious_idx, 'features'] = new_m_features
    df.to_csv('test.csv', index=False)
    
    """
    
    
  

    
    
        


if __name__ == '__main__':
    #feature_generate('dataset/feature_extraction_realworld.csv')
    #high_similar_malware_processing()
    high_similar_malware_processing_BGE()
